# Copyright (c) 2021-2025 community-scripts ORG
# License: MIT | https://raw.githubusercontent.com/community-scripts/ProxmoxVED/main/LICENSE

set -euo pipefail
SPINNER_PID=""
SPINNER_ACTIVE=0
SPINNER_MSG=""
declare -A MSG_INFO_SHOWN

# ------------------------------------------------------------------------------
# Loads core utility groups once (colors, formatting, icons, defaults).
# ------------------------------------------------------------------------------

[[ -n "${_CORE_FUNC_LOADED:-}" ]] && return
_CORE_FUNC_LOADED=1

load_functions() {
  [[ -n "${__FUNCTIONS_LOADED:-}" ]] && return
  __FUNCTIONS_LOADED=1
  color
  formatting
  icons
  default_vars
  # add more
}

# ------------------------------------------------------------------------------
# Sets ANSI color codes used for styled terminal output.
# ------------------------------------------------------------------------------
color() {
  YW=$(echo "\033[33m")
  YWB=$(echo "\033[93m")
  BL=$(echo "\033[36m")
  RD=$(echo "\033[01;31m")
  BGN=$(echo "\033[4;92m")
  GN=$(echo "\033[1;92m")
  DGN=$(echo "\033[32m")
  CL=$(echo "\033[m")
}

# ------------------------------------------------------------------------------
# Defines formatting helpers like tab, bold, and line reset sequences.
# ------------------------------------------------------------------------------
formatting() {
  BFR="\\r\\033[K"
  BOLD=$(echo "\033[1m")
  HOLD=" "
  TAB="  "
}

# ------------------------------------------------------------------------------
# Sets symbolic icons used throughout user feedback and prompts.
# ------------------------------------------------------------------------------
icons() {
  CM="${TAB}✔️${TAB}"
  CROSS="${TAB}✖️${TAB}"
  INFO="${TAB}💡${TAB}${CL}"
  OS="${TAB}🖥️${TAB}${CL}"
  OSVERSION="${TAB}🌟${TAB}${CL}"
  CONTAINERTYPE="${TAB}📦${TAB}${CL}"
  DISKSIZE="${TAB}💾${TAB}${CL}"
  CPUCORE="${TAB}🧠${TAB}${CL}"
  RAMSIZE="${TAB}🛠️${TAB}${CL}"
  SEARCH="${TAB}🔍${TAB}${CL}"
  VERBOSE_CROPPED="🔍${TAB}"
  VERIFYPW="${TAB}🔐${TAB}${CL}"
  CONTAINERID="${TAB}🆔${TAB}${CL}"
  HOSTNAME="${TAB}🏠${TAB}${CL}"
  BRIDGE="${TAB}🌉${TAB}${CL}"
  NETWORK="${TAB}📡${TAB}${CL}"
  GATEWAY="${TAB}🌐${TAB}${CL}"
  DISABLEIPV6="${TAB}🚫${TAB}${CL}"
  DEFAULT="${TAB}⚙️${TAB}${CL}"
  MACADDRESS="${TAB}🔗${TAB}${CL}"
  VLANTAG="${TAB}🏷️${TAB}${CL}"
  ROOTSSH="${TAB}🔑${TAB}${CL}"
  CREATING="${TAB}🚀${TAB}${CL}"
  ADVANCED="${TAB}🧩${TAB}${CL}"
}

# ------------------------------------------------------------------------------
# Sets default retry and wait variables used for system actions.
# ------------------------------------------------------------------------------
default_vars() {
  RETRY_NUM=10
  RETRY_EVERY=3
  i=$RETRY_NUM
}

# ------------------------------------------------------------------------------
# Performs a curl request with retry logic and inline feedback.
# ------------------------------------------------------------------------------
curl_handler() {
  local args=()
  local url=""
  local max_retries=3 delay=2 attempt=1 result exit_code
  local has_output_file=false

  # Argumente parsen
  for arg in "$@"; do
    if [[ "$arg" != -* && -z "$url" ]]; then
      url="$arg"
    fi
    [[ "$arg" == "-o" || "$arg" == --output ]] && has_output_file=true
    args+=("$arg")
  done

  if [[ -z "$url" ]]; then
    msg_error "no valid url or option entered for curl_handler"
    return 1
  fi

  msg_info "Fetching: $url"

  while :; do
    result=$(curl --retry 0 "${args[@]}" 2>&1)
    exit_code=$?

    if [[ $exit_code -eq 0 ]]; then
      stop_spinner
      msg_ok "Fetched: $url"
      $has_output_file || printf '%s' "$result"
      return 0
    fi

    if ((attempt >= max_retries)); then
      stop_spinner
      __curl_err_handler "$exit_code" "$url"
      return 1
    fi

    printf "\r\033[K${INFO}${YW}Retry $attempt/$max_retries in ${delay}s...${CL}" >&2
    sleep "$delay"
    ((attempt++))
  done
}

# ------------------------------------------------------------------------------
# Handles specific curl error codes and displays descriptive messages.
# ------------------------------------------------------------------------------
__curl_err_handler() {
  local exit_code="$1"
  local target="$2"
  case $exit_code in
  1) msg_error "Unsupported protocol: $target" ;;
  2) msg_error "Curl init failed: $target" ;;
  3) msg_error "Malformed URL: $target" ;;
  5) msg_error "Proxy resolution failed: $target" ;;
  6) msg_error "Host resolution failed: $target" ;;
  7) msg_error "Connection failed: $target" ;;
  9) msg_error "Access denied: $target" ;;
  18) msg_error "Partial file transfer: $target" ;;
  22) msg_error "HTTP error (e.g. 404): $target" ;;
  23) msg_error "Write error on local system: $target" ;;
  26) msg_error "Read error from local file: $target" ;;
  28) msg_error "Timeout: $target" ;;
  35) msg_error "SSL connect error: $target" ;;
  47) msg_error "Too many redirects: $target" ;;
  51) msg_error "SSL cert verify failed: $target" ;;
  52) msg_error "Empty server response: $target" ;;
  55) msg_error "Send error: $target" ;;
  56) msg_error "Receive error: $target" ;;
  60) msg_error "SSL CA not trusted: $target" ;;
  67) msg_error "Login denied by server: $target" ;;
  78) msg_error "Remote file not found (404): $target" ;;
  *) msg_error "Curl failed with code $exit_code: $target" ;;
  esac
}

# ------------------------------------------------------------------------------
# Spinner trap: ensures spinner is stopped on termination signals.
# ------------------------------------------------------------------------------
trap 'stop_spinner' EXIT INT TERM HUP

# ------------------------------------------------------------------------------
# Starts a spinner animation for ongoing async operations.
# ------------------------------------------------------------------------------
start_spinner() {
  local msg="$1"
  local frames=(⠋ ⠙ ⠹ ⠸ ⠼ ⠴ ⠦ ⠧ ⠇ ⠏)
  local spin_i=0
  local interval=0.1

  SPINNER_MSG="$msg"
  printf "\r\e[2K" >&2

  {
    while [[ "$SPINNER_ACTIVE" -eq 1 ]]; do
      printf "\r\e[2K%s %b" "${TAB}${frames[spin_i]}${TAB}" "${YW}${SPINNER_MSG}${CL}" >&2
      spin_i=$(((spin_i + 1) % ${#frames[@]}))
      sleep "$interval"
    done
  } &

  SPINNER_PID=$!
  disown "$SPINNER_PID"
}

# ------------------------------------------------------------------------------
# Stops the spinner animation and resets its state.
# ------------------------------------------------------------------------------
stop_spinner() {
  if [[ -n "${SPINNER_PID:-}" ]] && kill -0 "$SPINNER_PID" 2>/dev/null; then
    kill "$SPINNER_PID" 2>/dev/null
    sleep 0.1
    kill -0 "$SPINNER_PID" 2>/dev/null && kill -9 "$SPINNER_PID" 2>/dev/null
    wait "$SPINNER_PID" 2>/dev/null || true
  fi
  SPINNER_ACTIVE=0
  unset SPINNER_PID
}

# ------------------------------------------------------------------------------
# Stops the spinner if active, used to avoid multiple spinners.
# ------------------------------------------------------------------------------
spinner_guard() {
  if [[ "$SPINNER_ACTIVE" -eq 1 ]] && [[ -n "${SPINNER_PID:-}" ]]; then
    kill "$SPINNER_PID" 2>/dev/null
    wait "$SPINNER_PID" 2>/dev/null || true
    SPINNER_ACTIVE=0
    unset SPINNER_PID
  fi
}

# ------------------------------------------------------------------------------
# Displays an informational spinner once per message.
# ------------------------------------------------------------------------------
msg_info() {
  local msg="$1"
  [[ -n "${MSG_INFO_SHOWN["$msg"]+x}" ]] && return
  MSG_INFO_SHOWN["$msg"]=1

  spinner_guard
  SPINNER_ACTIVE=1
  start_spinner "$msg"
}

# ------------------------------------------------------------------------------
# Displays a success message and stops spinner.
# ------------------------------------------------------------------------------
msg_ok() {
  local msg="$1"
  stop_spinner
  printf "\r\e[2K%s %b\n" "${CM}" "${GN}${msg}${CL}" >&2
  unset MSG_INFO_SHOWN["$msg"]
}

# ------------------------------------------------------------------------------
# Displays an error message and stops spinner.
# ------------------------------------------------------------------------------
msg_error() {
  stop_spinner
  local msg="$1"
  printf "\r\e[2K%s %b\n" "${CROSS}" "${RD}${msg}${CL}" >&2
}
